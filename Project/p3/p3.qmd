---
title: "2020 Overwatch League Analysis"
output: html
runtime: shiny
format:
  html:
    code-fold: true
    code-summary: "Show the code"
---

```{r setup, include=FALSE}
library(readr)
library(dplyr)
library(tidyr)
library(tidyverse)
library(ggplot2)
library(gridExtra)


knitr::opts_chunk$set(warning = FALSE)

tank = "#ff7eb6" # IBM Magenta 40
damage = "#4589ff" # IBM Blue 50
support = "#3ddbd9" # IBM Teal 30
```

## Introduction to Overwatch (2020)

Overwatch is a team team-based shooter game with many heros that each come with their own abilities. In 2020, Overwatch League's gameplay involved teams of six engaging in 6v6 combat across various maps and objectives.

The game categorizes characters into three roles:

-   Tanks: These characters are the front line of every team. Tanks make space, absorb incoming damage, and set up plays for their teammates.
-   Damage: These characters are the follow up to the front line. They are either launching rockets from up behind cover or are deep behind enemy lines taking out their support.
-   Support: These characters usually take a back seat when it comes to eliminating the enemy team, by healing their team they ensure that their front-liners can take whatever comes at them, without getting taken out.

## Overwatch League: 2020 Season Analysis

The analysis focuses on the 2020 Overwatch League season, played on Overwatch's original format with six-player teams. This season is notable for its strategic and player dynamics, providing insight into player performances and tactics before Overwatch transitioned to a 5v5 format in its sequel, Overwatch 2.

The shift to 5v5 in Overwatch 2, particularly impacting the role and balance of Tank characters, offers an interesting contrast to the 2020 season data.

### Player Representation

The map below represents player nationality of which most players are from South Korea. We can see that most players are either from East Asian countries or Western Countries.

```{python player nationality map}
import pandas as pd
import geopandas as gpd
import plotly.express as px

# Load the provided data
file_path = 'overwatch_league_player_nationalities_updated.csv'  # Replace with your file path
players_data = pd.read_csv(file_path)

# Check if all values in 'Representation' are integers and convert accordingly
if (players_data['Representation'] % 1 == 0).all():
    players_data['Representation'] = players_data['Representation'].astype(int)
else:
    players_data['Representation'] = players_data['Representation'].astype(float)

# Load world data
world = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))

# Merge the world data with the players data
world_data = world.merge(players_data, left_on='name', right_on='Country / Region', how='left')

# Create the Plotly choropleth map
fig = px.choropleth(world_data,
                    geojson=world_data.geometry,
                    locations=world_data.index,
                    color="Representation",
                    color_continuous_scale="Viridis",
                    labels={'Representation':'Number of Players'})

fig.update_geos(fitbounds="locations")
```

```{r analysis setup, include=FALSE}
# Function to calculate the mode
Mode <- function(x) {
    ux <- unique(x)
    if (length(ux) == 1) {
        return(ux)
    } # If there's only one unique value, return it
    tab <- tabulate(match(x, ux))
    ux[tab == max(tab)]
}

# Load the filtered dataset without "All Heroes"
file_path <- "phs_2020_1_no_all_heroes.csv"
data <- read_csv(file_path)

# Mapping of hero names to their roles
hero_roles <- c(
    "D.Va" = "Tank", "Doomfist" = "Tank", "Junker Queen" = "Tank", "Mauga" = "Tank",
    "Orisa" = "Tank", "Ramattra" = "Tank", "Reinhardt" = "Tank", "Roadhog" = "Tank",
    "Sigma" = "Tank", "Winston" = "Tank", "Wrecking Ball" = "Tank", "Zarya" = "Tank",
    "Ashe" = "Damage", "Bastion" = "Damage", "McCree" = "Damage", "Echo" = "Damage",
    "Genji" = "Damage", "Hanzo" = "Damage", "Junkrat" = "Damage", "Mei" = "Damage",
    "Pharah" = "Damage", "Reaper" = "Damage", "Sojourn" = "Damage",
    "Soldier: 76" = "Damage", "Sombra" = "Damage", "Symmetra" = "Damage",
    "Torbjörn" = "Damage", "Tracer" = "Damage", "Widowmaker" = "Damage",
    "Ana" = "Support", "Baptiste" = "Support", "Brigitte" = "Support",
    "Illari" = "Support", "Kiriko" = "Support", "Lifeweaver" = "Support",
    "Lúcio" = "Support", "Mercy" = "Support", "Moira" = "Support", "Zenyatta" = "Support"
)

# Apply the role mapping to the eliminations data
data <- data %>%
    mutate(role = hero_roles[hero_name])

# Filter the dataset for rows where 'stat_name' is 'Eliminations'
eliminations_data <- filter(data, stat_name == "Eliminations")

# Calculate the average eliminations per game for each player
average_eliminations <- eliminations_data %>%
    group_by(player_name, esports_match_id) %>%
    summarise(avg_elim = mean(stat_amount), .groups = "drop") %>%
    group_by(player_name) %>%
    summarise(average_eliminations = mean(avg_elim), .groups = "drop")

# Determine the most common role for each player
player_roles <- eliminations_data %>%
    group_by(player_name) %>%
    summarise(common_role = Mode(role), .groups = "drop")

# Merge the player roles with the average eliminations
player_impact <- merge(average_eliminations, player_roles, by = "player_name")
```

## Machine Learning

To better understand which features are most relevant to a team winning a game, we are going to train and test machine learning models to be able to predict which team is going to win based on the dataset's features.

```{python ml, eval = FALSE}
# Import necessary libraries
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix
import numpy as np

# Load the dataset
data = pd.read_csv("merged_esports_data_updated.csv")

# Preprocess the data (fill missing values, one-hot encoding)
data = data.fillna(data.median(numeric_only=True))
data = pd.get_dummies(data, columns=["map_type", "map_name", "player_name", "team_name", "hero_name"])

# Drop irrelevant columns
data = data.drop(columns=["team_one_name", "team_two_name", "match_id"])

# Split the data into features and target
X = data.drop("match_winner", axis=1)
y = data["match_winner"]

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train models
lr_model = LogisticRegression().fit(X_train, y_train)
rf_model = RandomForestClassifier(n_estimators=50, random_state=42).fit(X_train, y_train)
gb_model = GradientBoostingClassifier(n_estimators=100, random_state=42).fit(X_train, y_train)

# Predictions and Evaluation
predictions_lr = lr_model.predict(X_test)
predictions_rf = rf_model.predict(X_test)
predictions_gb = gb_model.predict(X_test)

# Save predictions and true values for R
results = pd.DataFrame({
    "y_test": y_test,
    "predictions_lr": predictions_lr,
    "predictions_rf": predictions_rf,
    "predictions_gb": predictions_gb
})
results.to_csv("model_results.csv", index=False)

# Save feature importances for R
feature_importances = pd.DataFrame({
    "feature": X.columns,
    "importance_rf": rf_model.feature_importances_,
    "importance_gb": gb_model.feature_importances_
})
feature_importances.to_csv("feature_importances.csv", index=False)
```

From analyzing the feature importance, accuracy, sensitivity, and specificity of each model, we can see that the Random Forest model does the best job at correctly predicting which team is going to win.

```{r ml2, output = FALSE}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(caret)
library(reshape2)



# Read the model results and feature importances
results <- read.csv("model_results.csv")
feature_importances <- read.csv("feature_importances.csv")


# Selecting the top 10 important features for each model
top_features_rf <- feature_importances %>%
                   arrange(desc(importance_rf)) %>%
                   head(10)

top_features_gb <- feature_importances %>%
                   arrange(desc(importance_gb)) %>%
                   head(10)

# Confusion matrices and performance metrics
# Logistic Regression
cm_lr <- confusionMatrix(as.factor(results$predictions_lr), as.factor(results$y_test))
metrics_lr <- data.frame(Model = "Logistic Regression", Accuracy = cm_lr$overall['Accuracy'], Sensitivity = cm_lr$byClass['Sensitivity'], Specificity = cm_lr$byClass['Specificity'])

# Random Forest
cm_rf <- confusionMatrix(as.factor(results$predictions_rf), as.factor(results$y_test))
metrics_rf <- data.frame(Model = "Random Forest", Accuracy = cm_rf$overall['Accuracy'], Sensitivity = cm_rf$byClass['Sensitivity'], Specificity = cm_rf$byClass['Specificity'])

# Gradient Boosting
cm_gb <- confusionMatrix(as.factor(results$predictions_gb), as.factor(results$y_test))
metrics_gb <- data.frame(Model = "Gradient Boosting", Accuracy = cm_gb$overall['Accuracy'], Sensitivity = cm_gb$byClass['Sensitivity'], Specificity = cm_gb$byClass['Specificity'])

# Combine metrics and melt for ggplot
combined_metrics <- rbind(metrics_lr, metrics_rf, metrics_gb)
melted_metrics <- melt(combined_metrics, id.vars = "Model")

# Bar plot of accuracy, sensitivity, and specificity for each model
ggplot(melted_metrics, aes(x = variable, y = value, fill = variable)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    facet_wrap(~Model) +
    scale_fill_manual(values = c("Accuracy" = tank, "Sensitivity" = damage, "Specificity" = support)) +
    labs(x = "Metric", y = "Value", title = "Model Performance Comparison") +
    theme_minimal()
```

```{r ml3, echo = FALSE}
# Bar plot of accuracy, sensitivity, and specificity for each model
ggplot(melted_metrics, aes(x = variable, y = value, fill = variable)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    facet_wrap(~Model) +
    scale_fill_manual(values = c("Accuracy" = tank, "Sensitivity" = damage, "Specificity" = support)) +
    labs(x = "Metric", y = "Value", title = "Model Performance Comparison") +
    theme_minimal()
```

The Random Forest Model uses the in game statistics to determine which team is going to win, while the Gradient Boosting model mostly just picks it's favorite team. Logistic Regression couldn't identify any true negatives, and gradient boosting did not do that great either. So for the highest accuracy, and the most realistic true positive and best true negative predicting, Random Forest stands miles ahead of the other models trained.

```{r feature importance graph}
# Random Forest
ggplot(top_features_rf, aes(x = reorder(feature, importance_rf), y = importance_rf)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    labs(title = "Top 10 Feature Importances - Random Forest")
```

## Analyzing features based on the Random Forest's Feature Importance

### Average Time Alive

```{r average time alive box plot, output = FALSE}
time_alive_data <- filter(data, stat_name == "Average Time Alive")

avg_time_alive_by_hero <- time_alive_data %>%
    group_by(hero_name, role) %>%
    summarise(average_time_alive = mean(stat_amount, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(desc(average_time_alive))

# Reversing the order of heroes
ordered_heroes <- rev(avg_time_alive_by_hero$hero_name)

# Applying this reversed order to the box plot data
time_alive_data$hero_name <- factor(time_alive_data$hero_name, levels = ordered_heroes)

ggplot(time_alive_data, aes(x = hero_name, y = stat_amount, fill = role)) +
    geom_boxplot() +
    coord_flip() +
    labs(title = "Boxplot of Average Time Alive by Hero", x = "Hero", y = "Average Time Alive") +
    theme_minimal() +
    scale_fill_manual(values = c("Tank" = tank, "Damage" = damage, "Support" = support)) +
    theme(legend.position = "bottom")
```

```{r average tiem alive box plot2, echo = FALSE}
ggplot(time_alive_data, aes(x = hero_name, y = stat_amount, fill = role)) +
    geom_boxplot() +
    coord_flip() +
    labs(title = "Boxplot of Average Time Alive by Hero", x = "Hero", y = "Average Time Alive") +
    theme_minimal() +
    scale_fill_manual(values = c("Tank" = tank, "Damage" = damage, "Support" = support)) +
    theme(legend.position = "bottom")
```



### Average Objective Time

```{r objective time graphs, output = FALSE}
objective_time_data <- filter(data, stat_name == "Objective Time")

objective_time_by_hero <- objective_time_data %>%
    group_by(hero_name, role) %>%
    summarise(average_objective_time = mean(stat_amount, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(desc(average_objective_time))

# Reversing the order of heroes
ordered_heroes_objective <- rev(objective_time_by_hero$hero_name)

# Applying this reversed order to the box plot data
objective_time_data$hero_name <- factor(objective_time_data$hero_name, levels = ordered_heroes_objective)

ggplot(objective_time_data, aes(x = hero_name, y = stat_amount, fill = role)) +
    geom_boxplot() +
    coord_flip() +
    labs(title = "Boxplot of Objective Time by Hero", x = "Hero", y = "Objective Time") +
    theme_minimal() +
    scale_fill_manual(values = c("Tank" = tank, "Damage" = damage, "Support" = support))
```

```{r objective time graph2, echo = FALSE}
ggplot(objective_time_data, aes(x = hero_name, y = stat_amount, fill = role)) +
    geom_boxplot() +
    coord_flip() +
    labs(title = "Boxplot of Objective Time by Hero", x = "Hero", y = "Objective Time") +
    theme_minimal() +
    scale_fill_manual(values = c("Tank" = tank, "Damage" = damage, "Support" = support))
```

### Average Healing Done

```{r healing done plot, include = FALSE}
# Filtering data for "Healing Done"
healing_done_data <- filter(data, stat_name == "Healing Done")

# Calculating the average healing done by hero and role
average_healing_by_hero <- healing_done_data %>%
    group_by(hero_name, role) %>%
    summarise(average_healing_done = mean(stat_amount, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(desc(average_healing_done))

# Reversing the order of heroes based on the average healing done
ordered_heroes_healing <- rev(average_healing_by_hero$hero_name)

# Applying this reversed order to the box plot data
healing_done_data$hero_name <- factor(healing_done_data$hero_name, levels = ordered_heroes_healing)

# Creating the box plot with the ordered hero names
ggplot(healing_done_data, aes(x = hero_name, y = stat_amount, fill = role)) +
    geom_boxplot() +
    coord_flip() +
    labs(title = "Boxplot of Healing Done by Hero", x = "Hero", y = "Healing Done") +
    theme_minimal() +
    scale_fill_manual(values = c("Tank" = tank, "Damage" = damage, "Support" = support))
```

```{r healing done plot2, echo = FALSE}
ggplot(healing_done_data, aes(x = hero_name, y = stat_amount, fill = role)) +
    geom_boxplot() +
    coord_flip() +
    labs(title = "Boxplot of Healing Done by Hero", x = "Hero", y = "Healing Done") +
    theme_minimal() +
    scale_fill_manual(values = c("Tank" = tank, "Damage" = damage, "Support" = support))
```

### Average Eliminations

```{r elimination graph, output = FALSE}
average_eliminations_by_hero <- eliminations_data %>%
    group_by(hero_name, role) %>%
    summarise(average_eliminations = mean(stat_amount, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(desc(average_eliminations))

# Reversing the order of heroes based on the average eliminations
ordered_heroes_eliminations <- rev(average_eliminations_by_hero$hero_name)

# Applying this reversed order to the box plot data
eliminations_data$hero_name <- factor(eliminations_data$hero_name, levels = ordered_heroes_eliminations)

# Creating the box plot with the ordered hero names
ggplot(eliminations_data, aes(x = hero_name, y = stat_amount, fill = role)) +
    geom_boxplot() +
    coord_flip() +
    labs(title = "Boxplot of Eliminations by Hero", x = "Hero", y = "Number of Eliminations") +
    theme_minimal() +
    scale_fill_manual(values = c("Tank" = tank, "Damage" = damage, "Support" = support))
```

```{r elimination graph2, echo = FALSE}
ggplot(eliminations_data, aes(x = hero_name, y = stat_amount, fill = role)) +
    geom_boxplot() +
    coord_flip() +
    labs(title = "Boxplot of Eliminations by Hero", x = "Hero", y = "Number of Eliminations") +
    theme_minimal() +
    scale_fill_manual(values = c("Tank" = tank, "Damage" = damage, "Support" = support))
```


## Comparing our features next to each other

```{python}
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Read the dataset using the relative path
owl2020_data = pd.read_csv('owl2020data.csv')

hero_roles = {
    "D.Va": "Tank", "Reinhardt": "Tank", "Winston": "Tank", "Roadhog": "Tank", "Zarya": "Tank", 
    "Orisa": "Tank", "Sigma": "Tank", "Wrecking Ball": "Tank", "Doomfist": "Damage", 
    "Genji": "Damage", "McCree": "Damage", "Pharah": "Damage", "Reaper": "Damage", 
    "Soldier: 76": "Damage", "Sombra": "Damage", "Tracer": "Damage", "Bastion": "Damage", 
    "Hanzo": "Damage", "Junkrat": "Damage", "Mei": "Damage", "Torbjörn": "Damage", 
    "Widowmaker": "Damage", "D.Va": "Tank", "Orisa": "Tank", "Reinhardt": "Tank", 
    "Roadhog": "Tank", "Winston": "Tank", "Wrecking Ball": "Tank", "Zarya": "Tank", 
    "Ana": "Support", "Baptiste": "Support", "Brigitte": "Support", "Lúcio": "Support", 
    "Mercy": "Support", "Moira": "Support", "Zenyatta": "Support"
}

# Assign roles to each row in the owl2020 data
owl2020_data['role'] = owl2020_data['hero_name'].map(hero_roles)

# Custom color palette based on roles
custom_palette = {
    "Tank": "#ff7eb6",    # IBM Magenta 40
    "Damage": "#4589ff",  # IBM Blue 50
    "Support": "#3ddbd9"  # IBM Teal 30
}

# Create scatter plots with custom colors mapped to roles
plt.figure(figsize=(18, 6))

# Scatter plot for Average Time Alive vs. Eliminations, colored by role
plt.subplot(1, 3, 1)
sns.scatterplot(x='average_time_alive', y='eliminations', hue='role', data=owl2020_data, palette=custom_palette)
plt.title('Average Time Alive vs. Eliminations')
plt.xlabel('Average Time Alive (sec)')
plt.ylabel('Eliminations')

# Scatter plot for Objective Time vs. Eliminations, colored by role
plt.subplot(1, 3, 2)
sns.scatterplot(x='objective_time', y='eliminations', hue='role', data=owl2020_data, palette=custom_palette)
plt.title('Objective Time vs. Eliminations')
plt.xlabel('Objective Time (sec)')
plt.ylabel('Eliminations')

# Scatter plot for Average Time Alive vs. Objective Time, colored by role
plt.subplot(1, 3, 3)
sns.scatterplot(x='average_time_alive', y='objective_time', hue='role', data=owl2020_data, palette=custom_palette)
plt.title('Average Time Alive vs. Objective Time')
plt.xlabel('Average Time Alive (sec)')
plt.ylabel('Objective Time (sec)')

plt.tight_layout()
plt.show()
```

## Summary

Overall this analysis has given us a good understanding of which players and heroes performed the best throughout the 2020 Overwatch League Season. If this was a game played by robots we would now be able to accurately predict which team was going to win every time, and which heroes should be picked. Alas, there are many things that cannot be evaluated by the statistics tracked in game. The decision making skills of the in-game leaders, the individual decisions that all 12 players are making in the heat of the moment, as well as the abilities that cannot be well measured like Lucio's speed boost.